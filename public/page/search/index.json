[{"content":"Introduction to Java Streams API Java 8 introduced one of the most significant features to the language: the Streams API. This powerful addition allows developers to process collections of objects in a declarative way, similar to SQL queries.\nWhat are Streams? Streams represent a sequence of elements and support different kinds of operations to perform computations on those elements. Operations on streams can be either intermediate or terminal.\nIntermediate operations return a new stream and are always lazy (they don\u0026rsquo;t process the stream until a terminal operation is invoked) Terminal operations produce a result or a side-effect and trigger the processing of the stream pipeline Basic Stream Operations Let\u0026rsquo;s look at some common operations:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;John\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Mark\u0026#34;, \u0026#34;Tanya\u0026#34;, \u0026#34;Robert\u0026#34;); // Filtering a stream List\u0026lt;String\u0026gt; longNames = names.stream() .filter(name -\u0026gt; name.length() \u0026gt; 4) .collect(Collectors.toList()); // Result: [Sarah, Tanya, Robert] // Mapping values List\u0026lt;Integer\u0026gt; nameLengths = names.stream() .map(String::length) .collect(Collectors.toList()); // Result: [4, 5, 4, 5, 6] // Finding elements Optional\u0026lt;String\u0026gt; startsWithR = names.stream() .filter(name -\u0026gt; name.startsWith(\u0026#34;R\u0026#34;)) .findFirst(); // Result: Optional[Robert] The Power of Method References Java 8 introduced method references as a shorthand notation for lambda expressions:\n1 2 3 4 5 // Instead of: names.stream().map(name -\u0026gt; name.toUpperCase()) // You can use: names.stream().map(String::toUpperCase) Parallel Streams One of the most powerful features of the Streams API is the ability to easily parallelize operations:\n1 2 3 4 5 // Sequential processing long count = names.stream().filter(name -\u0026gt; name.length() \u0026gt; 4).count(); // Parallel processing long parallelCount = names.parallelStream().filter(name -\u0026gt; name.length() \u0026gt; 4).count(); Conclusion The Java Streams API provides a modern and functional approach to working with collections. It improves code readability, reduces boilerplate code, and offers opportunities for optimization through parallelism.\nIn future posts, we\u0026rsquo;ll explore more advanced stream operations like reduce, collect, and flatMap.\n","date":"2025-01-15T09:00:00Z","image":"http://localhost:1313/post/java-streams-introduction/image_hu_8a03d3f0f0fd2f8c.png","permalink":"http://localhost:1313/post/java-streams-introduction/","title":"Introduction to Java Streams API"},{"content":"Building RESTful APIs with Spring Boot Spring Boot has revolutionized the way we build Java applications, especially when it comes to creating RESTful APIs. In this post, we\u0026rsquo;ll walk through the process of building a simple but robust REST API using Spring Boot.\nSetting Up the Project The easiest way to start a Spring Boot project is by using the Spring Initializer (https://start.spring.io/). For our REST API, we\u0026rsquo;ll need the following dependencies:\nSpring Web Spring Data JPA H2 Database (for development) Lombok (optional, but helpful) Creating the Data Model Let\u0026rsquo;s create a simple entity for our API:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Entity @Data public class Product { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotBlank private String name; private String description; @Positive private BigDecimal price; @CreationTimestamp private LocalDateTime createdAt; @UpdateTimestamp private LocalDateTime updatedAt; } Repository Layer Spring Data JPA makes it incredibly easy to create a repository:\n1 2 3 public interface ProductRepository extends JpaRepository\u0026lt;Product, Long\u0026gt; { List\u0026lt;Product\u0026gt; findByNameContaining(String name); } This interface automatically provides methods for CRUD operations, and we\u0026rsquo;ve added a custom query method.\nService Layer The service layer contains our business logic:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Service @RequiredArgsConstructor public class ProductService { private final ProductRepository productRepository; public List\u0026lt;Product\u0026gt; getAllProducts() { return productRepository.findAll(); } public Product getProductById(Long id) { return productRepository.findById(id) .orElseThrow(() -\u0026gt; new ResourceNotFoundException(\u0026#34;Product not found\u0026#34;)); } public Product createProduct(Product product) { return productRepository.save(product); } public Product updateProduct(Long id, Product productDetails) { Product product = getProductById(id); product.setName(productDetails.getName()); product.setDescription(productDetails.getDescription()); product.setPrice(productDetails.getPrice()); return productRepository.save(product); } public void deleteProduct(Long id) { Product product = getProductById(id); productRepository.delete(product); } public List\u0026lt;Product\u0026gt; searchProducts(String keyword) { return productRepository.findByNameContaining(keyword); } } Controller Layer Now let\u0026rsquo;s create the REST endpoints:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @RestController @RequestMapping(\u0026#34;/api/products\u0026#34;) @RequiredArgsConstructor public class ProductController { private final ProductService productService; @GetMapping public List\u0026lt;Product\u0026gt; getAllProducts() { return productService.getAllProducts(); } @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Product\u0026gt; getProductById(@PathVariable Long id) { Product product = productService.getProductById(id); return ResponseEntity.ok(product); } @PostMapping public ResponseEntity\u0026lt;Product\u0026gt; createProduct(@Valid @RequestBody Product product) { Product createdProduct = productService.createProduct(product); URI location = ServletUriComponentsBuilder.fromCurrentRequest() .path(\u0026#34;/{id}\u0026#34;) .buildAndExpand(createdProduct.getId()) .toUri(); return ResponseEntity.created(location).body(createdProduct); } @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Product\u0026gt; updateProduct(@PathVariable Long id, @Valid @RequestBody Product productDetails) { Product updatedProduct = productService.updateProduct(id, productDetails); return ResponseEntity.ok(updatedProduct); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; deleteProduct(@PathVariable Long id) { productService.deleteProduct(id); return ResponseEntity.ok().build(); } @GetMapping(\u0026#34;/search\u0026#34;) public List\u0026lt;Product\u0026gt; searchProducts(@RequestParam String keyword) { return productService.searchProducts(keyword); } } Exception Handling To make our API robust, we need proper exception handling:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(ResourceNotFoundException.class) public ResponseEntity\u0026lt;?\u0026gt; handleResourceNotFoundException(ResourceNotFoundException ex) { Map\u0026lt;String, String\u0026gt; response = Map.of(\u0026#34;error\u0026#34;, ex.getMessage()); return new ResponseEntity\u0026lt;\u0026gt;(response, HttpStatus.NOT_FOUND); } @ExceptionHandler(MethodArgumentNotValidException.class) public ResponseEntity\u0026lt;?\u0026gt; handleValidationExceptions(MethodArgumentNotValidException ex) { Map\u0026lt;String, String\u0026gt; errors = new HashMap\u0026lt;\u0026gt;(); ex.getBindingResult().getFieldErrors().forEach(error -\u0026gt; errors.put(error.getField(), error.getDefaultMessage())); return new ResponseEntity\u0026lt;\u0026gt;(errors, HttpStatus.BAD_REQUEST); } } Testing the API For a comprehensive API, we should have both unit and integration tests:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @SpringBootTest @AutoConfigureMockMvc class ProductControllerTest { @Autowired private MockMvc mockMvc; @Autowired private ObjectMapper objectMapper; @Autowired private ProductRepository productRepository; @Test void shouldCreateProduct() throws Exception { Product product = new Product(); product.setName(\u0026#34;Test Product\u0026#34;); product.setDescription(\u0026#34;Test Description\u0026#34;); product.setPrice(new BigDecimal(\u0026#34;9.99\u0026#34;)); mockMvc.perform(post(\u0026#34;/api/products\u0026#34;) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(product))) .andExpect(status().isCreated()) .andExpect(jsonPath(\u0026#34;$.name\u0026#34;).value(\u0026#34;Test Product\u0026#34;)); } // More tests... } Conclusion Spring Boot provides a powerful and efficient way to build RESTful APIs. With minimal configuration, we can focus on our business logic while Spring handles the repetitive tasks. The combination of Spring Boot, Spring Data JPA, and Spring MVC offers a complete toolset for API development.\nIn future posts, we\u0026rsquo;ll explore more advanced features like security, caching, and documentation for Spring Boot APIs.\n","date":"2023-12-10T10:15:00Z","image":"http://localhost:1313/post/spring-boot-rest-api/image_hu_1b3ca765af243167.png","permalink":"http://localhost:1313/post/spring-boot-rest-api/","title":"Building RESTful APIs with Spring Boot"},{"content":"Core Principles of Test-Driven Development Test-Driven Development (TDD) is a software development approach where tests are written before the code they are testing. This article explores the fundamental principles of TDD and how to implement it effectively in your projects.\nThe TDD Cycle: Red, Green, Refactor The TDD approach follows a simple yet powerful cycle:\nRed: Write a failing test for the functionality you want to implement Green: Write just enough code to make the test pass Refactor: Improve the code without changing its functionality This cycle is repeated for each new feature or functionality, ensuring that every line of code is backed by a test.\nExample: TDD in Action Let\u0026rsquo;s see TDD in action with a simple example. Imagine we\u0026rsquo;re creating a calculator application:\nStep 1: Write a failing test 1 2 3 4 5 @Test public void testAddition() { Calculator calculator = new Calculator(); assertEquals(5, calculator.add(2, 3)); } Running this test will fail because we haven\u0026rsquo;t implemented the Calculator class yet.\nStep 2: Write code to make the test pass 1 2 3 4 5 public class Calculator { public int add(int a, int b) { return a + b; } } Now our test passes.\nStep 3: Refactor if necessary In this simple example, there might not be much to refactor. As our calculator grows more complex, we would refactor while ensuring all tests continue to pass.\nBenefits of TDD Higher code quality: Tests catch bugs early in the development process Better design: Writing tests first encourages more modular, loosely coupled code Documentation: Tests serve as living documentation of how code should behave Confidence in changes: Tests provide a safety net when refactoring or adding features Reduced debugging time: Problems are identified at the source Common TDD Pitfalls Over-testing: Writing tests for every line of code, including implementation details Ignoring integration testing: Focusing only on unit tests without testing how components work together Abandoning TDD under pressure: Skipping tests when deadlines approach Testing the wrong things: Writing tests that don\u0026rsquo;t verify important behaviors Tools for TDD in Java JUnit and TestNG: The standard testing frameworks for Java Mockito: For creating mock objects in tests AssertJ: Provides fluent assertions for testing Hamcrest: Matchers that can be combined to create flexible expressions of intent Conclusion Test-Driven Development might seem counterintuitive at first, but it becomes a natural part of the development process with practice. The investment in writing tests first leads to more robust code and can actually speed up development by reducing debugging time and preventing regressions.\nIn future posts, we\u0026rsquo;ll explore more advanced TDD techniques and patterns for specific situations.\n","date":"2023-11-05T14:30:00Z","image":"http://localhost:1313/post/test-driven-development-principles/image_hu_61662e1ec67bc28c.png","permalink":"http://localhost:1313/post/test-driven-development-principles/","title":"Core Principles of Test-Driven Development"},{"content":"Why Related Content Matters Related content sections are a powerful way to keep visitors engaged with your website by suggesting relevant articles they might be interested in. They reduce bounce rates, increase page views, and improve the overall user experience by helping readers discover more of your content.\nHow Hugo Handles Related Content Hugo has a built-in system for identifying and displaying related content based on various factors like tags, categories, and publication dates. Unlike some other platforms that might use complex algorithms or third-party services, Hugo handles this functionality natively.\nConfiguring Related Content in Hugo Step 1: Add Related Content Configuration The first step is to add the related content configuration to your hugo.toml (or config.yaml/config.json):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 [related] # Include newer content in the relatedness calculation includeNewer = true # The minimum score a page must have to be considered related threshold = 60 # Convert tags/categories to lowercase before comparison toLower = false [[related.indices]] name = \u0026#34;tags\u0026#34; weight = 100 [[related.indices]] name = \u0026#34;categories\u0026#34; weight = 80 [[related.indices]] name = \u0026#34;date\u0026#34; weight = 10 This configuration tells Hugo:\nTo include newer content in the related content calculation (includeNewer = true) That a page must score at least 60 points to be considered related (threshold = 60) To match tags with a weight of 100, categories with a weight of 80, and consider publication date with a weight of 10 Step 2: Make Sure Your Content is Well-Tagged For Hugo to find related content, your posts need to be properly tagged and categorized. Add tags and categories to the front matter of your Markdown posts:\n1 2 3 4 5 6 --- title: \u0026#34;My Amazing Post\u0026#34; date: 2023-10-01 tags: [\u0026#34;hugo\u0026#34;, \u0026#34;web development\u0026#34;, \u0026#34;jamstack\u0026#34;] categories: [\u0026#34;tutorials\u0026#34;, \u0026#34;web\u0026#34;] --- The more specific and consistent your tagging system is, the better Hugo can match related content.\nStep 3: Styling the Related Content Section If you\u0026rsquo;re using the Hugo Stack theme like I am, the theme already includes basic styling for the related content section. However, you can customize it further by adding custom CSS:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Custom styles for related content */ .article-list--compact.related-content { margin-top: 2rem; border-top: 1px solid var(--card-separator-color); padding-top: 1.5rem; } .article-list--compact.related-content .article-title { font-size: 1.1rem; font-weight: 600; } .related-content header { margin-bottom: 1rem; } .related-content header h2 { font-size: 1.4rem; color: var(--accent-color); } Add this CSS to your site\u0026rsquo;s custom CSS file (usually in static/css/custom.css) and make sure it\u0026rsquo;s included in your site configuration.\nBest Practices for Effective Related Content 1. Use Specific and Consistent Tagging Tags are the primary way Hugo identifies related content. Use specific, descriptive tags and be consistent with your tagging system.\n2. Organize Content with Categories Categories provide another dimension for relating content. While tags can be more specific and numerous, categories should represent broader classifications of your content.\n3. Review and Adjust Related Content Settings Monitor how your related content appears on your site. If you find that Hugo is suggesting unrelated content, you might need to:\nIncrease the threshold value Adjust the weights of different indices Improve your tagging strategy 4. Consider Manual Related Content Links For especially important connections that Hugo might miss, you can manually add links to related content within your posts:\n1 2 3 ## Related Articles - [Getting Started with Hugo](/posts/getting-started-with-hugo/) - [Advanced Hugo Templates](/posts/advanced-hugo-templates/) Example: How Related Content Calculation Works Let\u0026rsquo;s say we have three posts:\nPost A: Tags: [hugo, markdown, templates], Categories: [tutorials] Post B: Tags: [hugo, css, design], Categories: [tutorials] Post C: Tags: [wordpress, cms], Categories: [reviews]\nWhen displaying related content for Post A:\nPost B scores: 100 (shared tag \u0026ldquo;hugo\u0026rdquo;) + 80 (shared category \u0026ldquo;tutorials\u0026rdquo;) = 180 Post C scores: 0 (no shared tags or categories) Since Post B exceeds our threshold of 60, it will be shown as related content, while Post C will not.\nConclusion Implementing related content in your Hugo site is a straightforward but powerful way to enhance the user experience and keep visitors engaged with your content. By properly configuring Hugo\u0026rsquo;s related content settings and maintaining a consistent tagging system, you can automatically suggest relevant articles to your readers and increase the time they spend on your site.\nBy using the built-in functionality of Hugo and the Hugo Stack theme, you can have an elegant related content section without any third-party services or complex plugins.\n","date":"2023-10-15T00:00:00Z","image":"http://localhost:1313/post/adding-related-content-to-hugo/cover_hu_a0bc2e9bccc7302f.png","permalink":"http://localhost:1313/post/adding-related-content-to-hugo/","title":"How to Add Related Content to Your Hugo Theme"},{"content":"SOLID Principles in Java: A Comprehensive Guide The SOLID principles are a set of five design principles that help developers create more maintainable, flexible, and scalable software. These principles were introduced by Robert C. Martin (Uncle Bob) and have become fundamental guidelines for object-oriented software design.\nWhat are SOLID Principles? SOLID is an acronym where each letter represents a principle:\nS: Single Responsibility Principle (SRP) O: Open/Closed Principle (OCP) L: Liskov Substitution Principle (LSP) I: Interface Segregation Principle (ISP) D: Dependency Inversion Principle (DIP) Let\u0026rsquo;s explore each principle with practical Java examples.\nSingle Responsibility Principle (SRP) A class should have only one reason to change.\nThis principle states that a class should be responsible for a single task or functionality.\nBad Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class UserService { public void registerUser(User user) { // Validate user if (user.getEmail() == null || !user.getEmail().contains(\u0026#34;@\u0026#34;)) { throw new IllegalArgumentException(\u0026#34;Invalid email\u0026#34;); } // Save user to database String sql = \u0026#34;INSERT INTO users (name, email) VALUES (?, ?)\u0026#34;; try (Connection conn = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost/mydb\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;); PreparedStatement stmt = conn.prepareStatement(sql)) { stmt.setString(1, user.getName()); stmt.setString(2, user.getEmail()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(e); } // Send confirmation email sendEmail(user.getEmail(), \u0026#34;Welcome\u0026#34;, \u0026#34;Welcome to our platform!\u0026#34;); } private void sendEmail(String to, String subject, String body) { // Code to send email System.out.println(\u0026#34;Email sent to \u0026#34; + to); } } Good Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class UserValidator { public void validate(User user) { if (user.getEmail() == null || !user.getEmail().contains(\u0026#34;@\u0026#34;)) { throw new IllegalArgumentException(\u0026#34;Invalid email\u0026#34;); } } } public class UserRepository { public void save(User user) { String sql = \u0026#34;INSERT INTO users (name, email) VALUES (?, ?)\u0026#34;; try (Connection conn = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost/mydb\u0026#34;, \u0026#34;user\u0026#34;, \u0026#34;password\u0026#34;); PreparedStatement stmt = conn.prepareStatement(sql)) { stmt.setString(1, user.getName()); stmt.setString(2, user.getEmail()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(e); } } } public class EmailService { public void sendWelcomeEmail(User user) { sendEmail(user.getEmail(), \u0026#34;Welcome\u0026#34;, \u0026#34;Welcome to our platform!\u0026#34;); } private void sendEmail(String to, String subject, String body) { // Code to send email System.out.println(\u0026#34;Email sent to \u0026#34; + to); } } public class UserService { private final UserValidator validator; private final UserRepository repository; private final EmailService emailService; public UserService(UserValidator validator, UserRepository repository, EmailService emailService) { this.validator = validator; this.repository = repository; this.emailService = emailService; } public void registerUser(User user) { validator.validate(user); repository.save(user); emailService.sendWelcomeEmail(user); } } Open/Closed Principle (OCP) Software entities should be open for extension but closed for modification.\nThis principle emphasizes that you should be able to extend a class\u0026rsquo;s behavior without modifying it.\nBad Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Rectangle { private double width; private double height; // Getters and setters public double area() { return width * height; } } public class Circle { private double radius; // Getters and setters public double area() { return Math.PI * radius * radius; } } public class AreaCalculator { public double calculateArea(Object shape) { if (shape instanceof Rectangle) { Rectangle rectangle = (Rectangle) shape; return rectangle.area(); } else if (shape instanceof Circle) { Circle circle = (Circle) shape; return circle.area(); } throw new IllegalArgumentException(\u0026#34;Unsupported shape\u0026#34;); } } Good Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public interface Shape { double area(); } public class Rectangle implements Shape { private double width; private double height; // Getters and setters @Override public double area() { return width * height; } } public class Circle implements Shape { private double radius; // Getters and setters @Override public double area() { return Math.PI * radius * radius; } } public class Triangle implements Shape { private double base; private double height; // Getters and setters @Override public double area() { return 0.5 * base * height; } } public class AreaCalculator { public double calculateArea(Shape shape) { return shape.area(); } } Liskov Substitution Principle (LSP) Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.\nThis principle is about ensuring that a derived class can stand in for its base class without causing issues.\nBad Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Rectangle { protected double width; protected double height; public void setWidth(double width) { this.width = width; } public void setHeight(double height) { this.height = height; } public double getWidth() { return width; } public double getHeight() { return height; } public double area() { return width * height; } } public class Square extends Rectangle { @Override public void setWidth(double width) { super.setWidth(width); super.setHeight(width); } @Override public void setHeight(double height) { super.setHeight(height); super.setWidth(height); } } // Client code public void testRectangle(Rectangle rectangle) { rectangle.setWidth(5); rectangle.setHeight(4); assert rectangle.area() == 20; // This fails for Square } Good Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public interface Shape { double area(); } public class Rectangle implements Shape { private double width; private double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } public double getWidth() { return width; } public double getHeight() { return height; } @Override public double area() { return width * height; } } public class Square implements Shape { private double side; public Square(double side) { this.side = side; } public double getSide() { return side; } @Override public double area() { return side * side; } } Interface Segregation Principle (ISP) Clients should not be forced to depend on methods they do not use.\nThis principle advises creating specific interfaces rather than one general-purpose interface.\nBad Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public interface Worker { void work(); void eat(); void sleep(); } public class Robot implements Worker { @Override public void work() { System.out.println(\u0026#34;Robot is working\u0026#34;); } @Override public void eat() { // Robots don\u0026#39;t eat, but we\u0026#39;re forced to implement this method throw new UnsupportedOperationException(\u0026#34;Robots don\u0026#39;t eat\u0026#34;); } @Override public void sleep() { // Robots don\u0026#39;t sleep, but we\u0026#39;re forced to implement this method throw new UnsupportedOperationException(\u0026#34;Robots don\u0026#39;t sleep\u0026#34;); } } Good Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface Workable { void work(); } public interface Eatable { void eat(); } public interface Sleepable { void sleep(); } public class Human implements Workable, Eatable, Sleepable { @Override public void work() { System.out.println(\u0026#34;Human is working\u0026#34;); } @Override public void eat() { System.out.println(\u0026#34;Human is eating\u0026#34;); } @Override public void sleep() { System.out.println(\u0026#34;Human is sleeping\u0026#34;); } } public class Robot implements Workable { @Override public void work() { System.out.println(\u0026#34;Robot is working\u0026#34;); } } Dependency Inversion Principle (DIP) High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.\nThis principle is about decoupling modules through abstractions.\nBad Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class EmailNotifier { public void sendEmail(String to, String subject, String body) { // Code to send email System.out.println(\u0026#34;Email sent to \u0026#34; + to); } } public class UserRegistrationService { private EmailNotifier emailNotifier = new EmailNotifier(); public void registerUser(User user) { // Save user to database // Send notification emailNotifier.sendEmail(user.getEmail(), \u0026#34;Welcome\u0026#34;, \u0026#34;Welcome to our platform!\u0026#34;); } } Good Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public interface NotificationService { void sendNotification(String recipient, String subject, String body); } public class EmailNotifier implements NotificationService { @Override public void sendNotification(String recipient, String subject, String body) { // Code to send email System.out.println(\u0026#34;Email sent to \u0026#34; + recipient); } } public class SMSNotifier implements NotificationService { @Override public void sendNotification(String recipient, String subject, String body) { // Code to send SMS System.out.println(\u0026#34;SMS sent to \u0026#34; + recipient); } } public class UserRegistrationService { private final NotificationService notificationService; public UserRegistrationService(NotificationService notificationService) { this.notificationService = notificationService; } public void registerUser(User user) { // Save user to database // Send notification notificationService.sendNotification(user.getEmail(), \u0026#34;Welcome\u0026#34;, \u0026#34;Welcome to our platform!\u0026#34;); } } Conclusion The SOLID principles provide a framework for writing maintainable and scalable code. When applied correctly, they help to:\nCreate more reusable code Reduce technical debt Make the codebase more robust to changes Improve readability and understanding of the code Make testing easier While these principles might seem abstract at first, with practice, they become invaluable tools in a developer\u0026rsquo;s arsenal for creating high-quality software.\nIn future posts, we\u0026rsquo;ll dive deeper into design patterns that build upon these SOLID principles to solve common software design challenges.\n","date":"2023-09-18T11:30:00Z","image":"http://localhost:1313/post/solid-principles/image_hu_28a203c39f0e77a8.png","permalink":"http://localhost:1313/post/solid-principles/","title":"SOLID Principles in Java: A Comprehensive Guide"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","image":"http://localhost:1313/post/markdown-syntax/image_hu_b702776a4b7e3da1.png","permalink":"http://localhost:1313/post/markdown-syntax/","title":"Markdown Syntax Guide"},{"content":"Essential Microservices Design Patterns Microservices architecture has become the standard for building scalable, resilient, and maintainable applications. However, distributed systems bring their own challenges. This post explores essential design patterns that help tackle these challenges effectively.\nCommunication Patterns 1. API Gateway Pattern The API Gateway acts as a single entry point for all clients. It routes requests to the appropriate microservice, aggregates responses, and handles cross-cutting concerns like authentication and rate limiting.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController public class ApiGatewayController { @Autowired private ProductService productService; @Autowired private ReviewService reviewService; @GetMapping(\u0026#34;/products/{id}\u0026#34;) public ProductDetails getProductDetails(@PathVariable Long id) { // Get product information Product product = productService.getProduct(id); // Get reviews for the product List\u0026lt;Review\u0026gt; reviews = reviewService.getReviewsForProduct(id); // Combine data and return return new ProductDetails(product, reviews); } } 2. Circuit Breaker Pattern The Circuit Breaker pattern prevents cascading failures by failing fast when a downstream service is unavailable.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class ProductService { @Autowired private RestTemplate restTemplate; @CircuitBreaker(name = \u0026#34;productService\u0026#34;, fallbackMethod = \u0026#34;getProductFallback\u0026#34;) public Product getProduct(Long id) { return restTemplate.getForObject( \u0026#34;http://product-service/products/\u0026#34; + id, Product.class ); } public Product getProductFallback(Long id, Exception e) { // Return a default product or cached data return new Product(id, \u0026#34;Fallback Product\u0026#34;, \u0026#34;This is a fallback response\u0026#34;, 0.0); } } 3. Saga Pattern The Saga pattern manages failures in distributed transactions by defining compensating actions for each step.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @Service public class OrderSaga { @Autowired private OrderService orderService; @Autowired private PaymentService paymentService; @Autowired private InventoryService inventoryService; @Autowired private ShippingService shippingService; @Transactional public OrderResult createOrder(Order order) { try { // Step 1: Create an order OrderEntity savedOrder = orderService.createOrder(order); try { // Step 2: Process payment Payment payment = paymentService.processPayment(order.getCustomerId(), order.getAmount()); try { // Step 3: Update inventory inventoryService.updateInventory(order.getItems()); try { // Step 4: Schedule shipping Shipping shipping = shippingService.scheduleDelivery(savedOrder); return new OrderResult(savedOrder, payment, shipping); } catch (Exception e) { // Compensate step 3 inventoryService.restoreInventory(order.getItems()); // Compensate step 2 paymentService.refundPayment(payment.getId()); // Compensate step 1 orderService.cancelOrder(savedOrder.getId()); throw e; } } catch (Exception e) { // Compensate step 2 paymentService.refundPayment(payment.getId()); // Compensate step 1 orderService.cancelOrder(savedOrder.getId()); throw e; } } catch (Exception e) { // Compensate step 1 orderService.cancelOrder(savedOrder.getId()); throw e; } } catch (Exception e) { throw new OrderCreationException(\u0026#34;Failed to create order\u0026#34;, e); } } } Data Management Patterns 1. Database per Service Each microservice has its own database, ensuring loose coupling and independent development.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Product Service Database (PostgreSQL) CREATE TABLE products ( id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL, description TEXT, price DECIMAL(10, 2) NOT NULL, stock INTEGER NOT NULL DEFAULT 0 ); // Order Service Database (MongoDB) { \u0026#34;_id\u0026#34;: ObjectId(\u0026#34;5fbd7c9d5d3b2c1a7c8f4a1b\u0026#34;), \u0026#34;customerId\u0026#34;: \u0026#34;customer123\u0026#34;, \u0026#34;items\u0026#34;: [ { \u0026#34;productId\u0026#34;: 101, \u0026#34;quantity\u0026#34;: 2, \u0026#34;price\u0026#34;: 29.99 }, { \u0026#34;productId\u0026#34;: 102, \u0026#34;quantity\u0026#34;: 1, \u0026#34;price\u0026#34;: 49.99 } ], \u0026#34;totalAmount\u0026#34;: 109.97, \u0026#34;status\u0026#34;: \u0026#34;PROCESSING\u0026#34;, \u0026#34;createdAt\u0026#34;: ISODate(\u0026#34;2023-08-24T10:15:30Z\u0026#34;) } 2. CQRS (Command Query Responsibility Segregation) Separate read and write operations for better scalability and performance.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Command side (Writes) @RestController @RequestMapping(\u0026#34;/products/commands\u0026#34;) public class ProductCommandController { @Autowired private ProductCommandService commandService; @PostMapping public ResponseEntity\u0026lt;String\u0026gt; createProduct(@RequestBody ProductCreateCommand command) { String productId = commandService.createProduct(command); return ResponseEntity.ok(productId); } @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; updateProduct(@PathVariable String id, @RequestBody ProductUpdateCommand command) { commandService.updateProduct(id, command); return ResponseEntity.ok().build(); } } // Query side (Reads) @RestController @RequestMapping(\u0026#34;/products/queries\u0026#34;) public class ProductQueryController { @Autowired private ProductQueryService queryService; @GetMapping public ResponseEntity\u0026lt;List\u0026lt;ProductDTO\u0026gt;\u0026gt; getAllProducts() { return ResponseEntity.ok(queryService.findAllProducts()); } @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;ProductDTO\u0026gt; getProduct(@PathVariable String id) { return queryService.findById(id) .map(ResponseEntity::ok) .orElse(ResponseEntity.notFound().build()); } } 3. Event Sourcing Store all changes to the application state as a sequence of events.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @Service public class ProductEventSourcingService { @Autowired private EventStore eventStore; @Autowired private ProductProjection productProjection; public void createProduct(CreateProductCommand command) { ProductCreatedEvent event = new ProductCreatedEvent( command.getProductId(), command.getName(), command.getDescription(), command.getPrice() ); eventStore.save(\u0026#34;product\u0026#34;, command.getProductId(), event); productProjection.apply(event); } public void updateProductPrice(UpdateProductPriceCommand command) { ProductPriceUpdatedEvent event = new ProductPriceUpdatedEvent( command.getProductId(), command.getNewPrice() ); eventStore.save(\u0026#34;product\u0026#34;, command.getProductId(), event); productProjection.apply(event); } public Product getProduct(String productId) { List\u0026lt;Event\u0026gt; events = eventStore.getEvents(\u0026#34;product\u0026#34;, productId); Product product = new Product(productId); for (Event event : events) { if (event instanceof ProductCreatedEvent) { ProductCreatedEvent e = (ProductCreatedEvent) event; product.setName(e.getName()); product.setDescription(e.getDescription()); product.setPrice(e.getPrice()); } else if (event instanceof ProductPriceUpdatedEvent) { ProductPriceUpdatedEvent e = (ProductPriceUpdatedEvent) event; product.setPrice(e.getNewPrice()); } // Handle other events } return product; } } Deployment Patterns 1. Sidecar Pattern Deploy helper services alongside the main service to handle cross-cutting concerns.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 apiVersion: v1 kind: Pod metadata: name: web-app labels: app: web spec: containers: - name: main-app image: my-web-app:latest ports: - containerPort: 8080 - name: log-collector image: log-collector:latest volumeMounts: - name: logs mountPath: /var/log - name: metrics-collector image: prometheus-agent:latest ports: - containerPort: 9090 volumes: - name: logs emptyDir: {} 2. Blue-Green Deployment Maintain two identical production environments to minimize downtime during deployments.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: application-ingress annotations: kubernetes.io/ingress.class: nginx spec: rules: - host: myapp.example.com http: paths: - path: / pathType: Prefix backend: service: name: green-service # Current active environment port: number: 80 --- # Later, after deploying the blue environment and verifying it works, # update the ingress to point to the blue service apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: application-ingress annotations: kubernetes.io/ingress.class: nginx spec: rules: - host: myapp.example.com http: paths: - path: / pathType: Prefix backend: service: name: blue-service # New active environment port: number: 80 Resilience Patterns 1. Bulkhead Pattern Isolate components to prevent failures from cascading through the system.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Service public class ResilientProductService { @Autowired private RestTemplate restTemplate; @Bulkhead(name = \u0026#34;productService\u0026#34;, type = Bulkhead.Type.THREADPOOL) public Product getProduct(Long id) { return restTemplate.getForObject( \u0026#34;http://product-service/products/\u0026#34; + id, Product.class ); } @Bulkhead(name = \u0026#34;inventoryService\u0026#34;, type = Bulkhead.Type.THREADPOOL) public Inventory getInventory(Long productId) { return restTemplate.getForObject( \u0026#34;http://inventory-service/inventory/product/\u0026#34; + productId, Inventory.class ); } } 2. Retry Pattern Automatically retry failed operations to handle transient failures.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service public class RetryableOrderService { @Autowired private RestTemplate restTemplate; @Retry(name = \u0026#34;orderService\u0026#34;, fallbackMethod = \u0026#34;createOrderFallback\u0026#34;) public Order createOrder(OrderRequest request) { return restTemplate.postForObject( \u0026#34;http://order-service/orders\u0026#34;, request, Order.class ); } public Order createOrderFallback(OrderRequest request, Exception e) { // Save to local queue for later processing return new Order(null, request.getCustomerId(), \u0026#34;PENDING\u0026#34;, new Date()); } } Conclusion Microservices design patterns help address the inherent challenges of distributed systems. By understanding and applying these patterns appropriately, developers can build more resilient, scalable, and maintainable microservices architectures.\nIt\u0026rsquo;s important to remember that these patterns are tools, not rules. Each has its own trade-offs, and the right pattern depends on your specific requirements and constraints.\nIn future posts, we\u0026rsquo;ll dive deeper into implementation details and explore how these patterns can be combined to solve complex architectural problems.\n","date":"2023-08-25T13:45:00Z","image":"http://localhost:1313/post/microservices-patterns/image_hu_f2ea6fc556fdb0d3.png","permalink":"http://localhost:1313/post/microservices-patterns/","title":"Essential Microservices Design Patterns"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi),e^{2 \\pi i \\xi x},d\\xi $$\n1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/post/math-typesetting/","title":"Math Typesetting"}]